# JUC

## 线程

### 线程和进程的关系

![image-20250823030059047](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250823030059047.png)

### JAVA的线程和操作系统的线程有啥区别

Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程）

在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。



### 私有的程序计数器、虚拟机栈、本地方法栈

#### 程序计数器

记录程序运行的阶段和实现代码的流程控制，一句话说白了就是为了线程切换后单个线程执行能回到之前的位置，所以必须是私有的

#### 虚拟机栈和本地方法栈

用来存变量的值的，局部的变量肯定得私有啊

### 线程的生命周期

![Java 线程状态变迁图](https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png)

### sleep()和wait()方法的区别

sleep()来自Thread线程的方法，直接对正在运行线程为对象，直接暂停线程

wait()来自Object，面向的是各种类，原理是通过释放锁然后今天waiting状态暂停线程

## 多线程

### 并发和并行、同步和异步

- **并发**：两个及两个以上的作业在同一 **时间段** 内执行。
- **并行**：两个及两个以上的作业在同一 **时刻** 执行。
- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。

### 意思是单核cpu就多线程不了吗？

fnndp!

就算只有单核的情况下，系统仍然可以通过时间片轮转的方式在不同线程中切换

#### 线程的调度

主要有抢占式和协同式，java的式抢占式

### 线程安全

就是同一份数据会被不同线程运行过程导致发送混乱或丢失

## 死锁

### 检测死锁和预防死锁

打破死锁的三个必要条件

1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

## JMM

## 乐观锁、悲观锁......等等锁

### 怎么实现乐观锁

#### CAS算法

全称是 **Compare And Swap（比较与交换）** ，用于实现乐观锁，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。

**CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。**

`sun.misc`包下的`Unsafe`类提供了`compareAndSwapObject`、`compareAndSwapInt`、`compareAndSwapLong`方法来实现的对`Object`、`int`、`long`类型的 CAS 操作：

##### CAS存在的问题

ABA 

循环时间长开销大

只能保证一个共享变量的原子操作

#### 版本号算法

在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。

## 各种关键字

### volaile

主要作用是用来**保证变量的可见性**，而且实现不是通过java甚至c语言里也有屌的不行，可惜就是**不能保证数据原子性**，因为他的原理只是禁用cpu缓存就是告诉编译器这个数据共享且不稳定。（synchronized就可以，牛的）

当然了还有另外一个作用就是**禁止指令重排序**

### synchronized

java6之前效率很低，因为监视器锁通过操作系统底层mutex lock实现；但是java6之后**引入大量优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作**的开销(偏向锁在jdk15中被默认关闭了jdk18直接没了)

修饰实力方法

修饰静态方法

```java
/*
静态和非静态方法调用不互斥
构造方法不可以用
*/
```

修饰代码块

synchronized原理上一直都是对**对象监视器monitor**的获取，不管是同步语句块的monitorenter、monitorexit还是修饰方法的ACC_SYNCHRONIZED标识

### ReentrantLock

底层通过**AQS**实现了Lock接口的**可重入独占锁**，相比较synchronized增加了轮询、超时、中断、公平锁和非公平锁等高级功能，默认是非公平锁。**synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API**

synchronized属于不可中断锁，`ReentrantLock` 就属于是可中断锁。

### ReentrantReadWriteLock

`ReentrantReadWriteLock` 实现了 `ReadWriteLock` ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。

```java
/*
一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。
读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。
*/
```

在线程持有读锁的情况下，该线程不能取得写锁

在线程持有写锁的情况下，该线程可以继续获取读锁

写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。

### StampedLock

 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 `Condition`。

基于 **CLH 锁** 独立实现

`StampedLock` 提供了三种模式的读写控制模式：

`读锁`	一个线程独占不可重入锁

`写锁`	多个线程共享悲观读锁，不可重入

`乐观读`	乐观锁可多个线程，单个写锁

### Atomic原子类

原子数据类型，都差不多

## 线程池

## ThreadLocal

## Future

## AQS

# JVM
