# 八股文

## MYsql

### 数据库三大范式

原子性 主键依赖 非主键不依赖

### char和var区别

char是定长字符串，没有用到的地方会用空格补足，适合存储固定长度的数据，例如身份证等。

varchar变长字符串，定义的时候只是指定了最大长度，实际上自己会变变，适合存储常变的数据，例如输入的文本。

### sql语句的执行过程

<span style="font-weight:bold;">单从语句上来说</span>从from里找到查看的表,对where中的条件对数据进行筛选，一般情况下返回第一个结果集，往后对下列的不同条件筛选根据上一个结果集返回下一个

**从引擎上说**

首先登录使用**连接器**经过tcp的三次握手后校验用户密码权限等，

(**查询缓存**，再8.0版本后已被删除)

**分析器**对语句关键字进行词法分析并语法分析，最后构建SQL语法树

**预处理**时会先检查被查询的表或数据名称是否存在、扩展 * 号

**优化器**会分析怎么连接顺序，使用哪种方式消耗资源成本少，使用索引?

最后根据不同引擎去**执行**

### 数据库引擎

#### innodb

有行锁，支持外键，支持事务，支持MVCC，最主要是支持事务就可以恢复

#### myisam

表锁，各种不支持

#### memory

曾经的缓存，使用内存储存并使用hash索引，最后被redis单线程的速度和优秀的过期机制代替

### 索引

#### 索引失效

最左匹配（不碍and），

运算或函数，

！=和<>操作符,

模糊查询，

隐藏的函数计算，例如null判断

#### 优化手段

避免回表查询，不使用select *

尽量使用覆盖索引

count(*)被innodb做优化

on非常慢，加索引

主键适保持自增

必要的时候索引下推

#### b和b+树

用来存储索引,5.5版本后mysql使用b+树做索引结构

b树每个节点都有存的数据，数据大的时候树层树增加，访问io变复杂

b+树只有叶子节点由数据，且叶子节点间有链指针,访问的时候树层级少导致了扫库和磁盘读写能力更强效率更稳定，同时天然具有排序功能

### 慢查询优化

慢查询日志记录了执行时间超过long_query_time（默认10s）的查询语句，再用explain对该sql进行分析（看看有没有用索引）//force index强制mysql走索引因为有时候会抽风

*尽量使用count(*)、避免回表、避免select *、insert慢使用递增主键*

<u>type表连接类型</u>

null没有表、system访问系统表、const使用了主键聚集或唯一索引、ref使用非唯一索引、index遍历整个索引树、all全表扫没索引

<u>key表使用的索引</u>

<u>extra意思是展示没有查到的信息</u>

### 事务和它的隔离级别

#### 事务的四大特性

**原子性**（undolog回滚实现）

**持久性**（redolog实现）

**隔离性**（mvcc+锁 配合 undolog实现）

**一致性**

#### 隔离性的问题

**脏读** 	读取到另一个事务没提交的数据

**不可重复读**	同一个事务中两次读取数据时不一致，例如被其他事务修改

**幻读**	事务再读取数据时被其他事务添加或减少了几条数据，<u>重点在条</u>

#### 事务的隔离级别（由低到高）

**读未提交**	啥都防不了

**读已提交**	事务提交后才能读取相同数据

**可重复读（MYsql默认）**	事务提交后读取当前的快照

**串行化**	不能并行，每次事务就上锁

### 各种锁

#### MVCC

*<u>多版本并发控制，其实说白了就是快照读写*</u>

依赖于隐式字段、undolog、readview

```java
/*
innodb通过数据的DB_TRX_ID和Read View判断数据可见性，
通过数据行DB_ROLL_PTR回滚指针快照读undolog中的应该的历史版本
*/
```



### 三种日志的作用过程

#### undolog回滚日志

<u>用于事务回滚和mvcc</u>

使事务出了问题回滚

#### redolog重做日志

<u>用于电脑爆炸等故障的恢复</u>

MySQL查询数据时会把查出来和要更新的数据的一页扔进BufferPool中，一段时间后再持久化到磁盘在持久化中由于是**随机写机制**所以刷盘慢的一笔，redolog就是用来保存BufferPool中数据的修改直接变成了**顺序写机制**，使他崩溃了也有机会恢复

#### binlog归档/二进制日志

<u>用于数据备份和主从复制</u>

记录了数据库更改的操作和语句，被依靠来同步数据保证一致性

### 主从复制和分库分表

主从复制优点：实时备份、读写分离、架构扩展

分表分库：垂直和水平



## Redis

### 快的原因

内存操作

单线程避免了线程频繁切换

非阻塞io多路复用机制

多种数据结构

#### 数据结构

基础数据类型String List Set Hash Zset

特殊数据类型HyperLogLogs Bitmap geo stream

### 常见应用

Hash中v存放结构化的对象且适合，常对字段进行操作

List两端存取，可以做栈和队列，常做消息队列和通过Irange做分页功能

Set主要用于去重，具体来说共同喜好（交集）音乐推荐（差集）

Sorted Set 带权Score，常做排行榜或优先级任务队列

bitmap，常做布隆过滤器

stream，消息队列

### 线程和多线程

Redis通过一个主线程单线程执行命令，但是再磁盘和网络io上会用多线程防止堵塞

*Redis6.0版本后采用多线程提高网络io的并行能力*

### 持久化和过期的策略

RDB持久化：内存快照

AOF持久化：读写日志（每秒/每次/自动）

*实际使用是是AOF+RDB混合的使用*

即，aof重写时子进程先rdb方法写进aof，再将之前的命令写进缓冲区，缓冲区再以aof方法写进aof文件，最后得到同时又rdb和aof格式的aof文件

### 三个主要的缓存问题

#### 缓存击穿

<u>*缓存中**key失效**了，大量请求击穿缓存区直接访问数据库*</u>

**互斥锁方案**（强一致性要求）

**逻辑过期方案**（假过期方法）

> *锁住只有一请求能问数据库，并且出问题的时候或者还没出问题的时候重建缓存*

#### 缓存穿透

<u>请求的**数据中很多不合法甚至都没有**，缓存区起不到作用，直接问数据库</u>

**缓存空对象**

**布隆过滤器**（简单查询）

> *重要让它能快点查到有没有或者说是当他默认有，有点服务熔断的味道了有没有*

#### 缓存雪崩

<u>缓存区中出现自然问题时比如**大量key同时过期**或**redis卡了**，大量请求访问数据库</u>

**过期时间打碎**

**主从或集群Redis**

**服务限流熔断降级**

#### 缓存读写策略

**旁路缓存策略**

写先更新数据库，数据持久化后再删除缓存

**读穿策略**

缓存解决不了问题的时候由缓存区请求数据库，再由缓冲区返给应用

**写穿策略**

更新数据时若缓存区中已有需要更新的数据则更新缓存区后由缓存区更新数据库，否则直接应用更新数据库

**写回策略**（适合写多，但是一致性比较弱）

即时仅更新缓存区，并设置数据脏。数据库这回异步定期从缓存区中更新数据库

### 分布式锁的实现和一致性问题

因为获取锁、判断锁、释放锁不具有原子性所以需要lua脚本

**redisson可重入锁**：hash结构

**可重试锁**：发布订阅模式，失败的时候订阅，有别的锁释放就发布消息

**超时锁续约**：看门狗机制建立守护线程，业务线程没完的时候会给锁加时间

**redlock红锁**：要半数以上加锁成功才算加锁成功

#### 锁的主从一致性问题

redisson联锁，要每个锁都加成功才算成功

### 集群和哨兵机制

哈哈，我懒得写



### 热点key和bigkey的处理

#### hotkey

**读写分离 和 二级缓存**

#### bigkey

--bigkeys

scan扫描
