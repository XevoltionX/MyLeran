# 八股文

## MYsql

### 数据库三大范式

原子性 主键依赖 非主键不依赖

### char和var区别

char是定长字符串，没有用到的地方会用空格补足，适合存储固定长度的数据，例如身份证等。

varchar变长字符串，定义的时候只是指定了最大长度，实际上自己会变变，适合存储常变的数据，例如输入的文本。

### sql语句的执行过程

<span style="font-weight:bold;">单从语句上来说</span>从from里找到查看的表,对where中的条件对数据进行筛选，一般情况下返回第一个结果集，往后对下列的不同条件筛选根据上一个结果集返回下一个

**从引擎上说**

首先登录使用**连接器**经过tcp的三次握手后校验用户密码权限等，

(**查询缓存**，再8.0版本后已被删除)

**分析器**对语句关键字进行词法分析并语法分析，最后构建SQL语法树

**预处理**时会先检查被查询的表或数据名称是否存在、扩展 * 号

**优化器**会分析怎么连接顺序，使用哪种方式消耗资源成本少，使用索引?

最后根据不同引擎去**执行**

### 数据库引擎

#### innodb

有行锁，支持外键，支持事务，支持MVCC，最主要是支持事务就可以恢复

#### myisam

表锁，各种不支持

#### memory

曾经的缓存，使用内存储存并使用hash索引，最后被redis单线程的速度和优秀的过期机制代替

### 索引

#### 索引失效

最左匹配（不碍and），

运算或函数，

！=和<>操作符,

模糊查询，

隐藏的函数计算，例如null判断

#### 优化手段

避免回表查询，不使用select *

尽量使用覆盖索引

count(*)被innodb做优化

on非常慢，加索引

主键适保持自增

必要的时候索引下推

#### b和b+树

用来存储索引,5.5版本后mysql使用b+树做索引结构

b树每个节点都有存的数据，数据大的时候树层树增加，访问io变复杂

b+树只有叶子节点由数据，且叶子节点间有链指针,访问的时候树层级少导致了扫库和磁盘读写能力更强效率更稳定，同时天然具有排序功能

### 慢查询优化

### 事务和它的隔离级别

### 各种锁

### 三种日志的作用过程

### 主从复制和分库分表





## Redis

### 快的原因

内存操作

单线程避免了线程频繁切换

非阻塞io多路复用机制

多种数据结构

#### 数据结构

基础数据类型String List Set Hash Zset

特殊数据类型HyperLogLogs Bitmap geo stream

### 常见应用

Hash中v存放结构化的对象且适合，常对字段进行操作

List两端存取，可以做栈和队列，常做消息队列和通过Irange做分页功能

Set主要用于去重，具体来说共同喜好（交集）音乐推荐（差集）

Sorted Set 带权Score，常做排行榜或优先级任务队列

bitmap，常做布隆过滤器

stream，消息队列

### 线程和多线程

Redis通过一个主线程单线程执行命令，但是再磁盘和网络io上会用多线程防止堵塞

*Redis6.0版本后采用多线程提高网络io的并行能力*

### 持久化和过期的策略

RDB持久化：内存快照

AOF持久化：读写日志（每秒/每次/自动）

*实际使用是是AOF+RDB混合的使用*

即，aof重写时子进程先rdb方法写进aof，再将之前的命令写进缓冲区，缓冲区再以aof方法写进aof文件，最后得到同时又rdb和aof格式的aof文件

### 三个主要的缓存问题

#### 缓存击穿

<u>*缓存中**key失效**了，大量请求击穿缓存区直接访问数据库*</u>

**互斥锁方案**（强一致性要求）

**逻辑过期方案**（假过期方法）

> *锁住只有一请求能问数据库，并且出问题的时候或者还没出问题的时候重建缓存*

#### 缓存穿透

<u>请求的**数据中很多不合法甚至都没有**，缓存区起不到作用，直接问数据库</u>

**缓存空对象**

**布隆过滤器**（简单查询）

> *重要让它能快点查到有没有或者说是当他默认有，有点服务熔断的味道了有没有*

#### 缓存雪崩

<u>缓存区中出现自然问题时比如**大量key同时过期**或**redis卡了**，大量请求访问数据库</u>

**过期时间打碎**

**主从或集群Redis**

**服务限流熔断降级**

#### 缓存读写策略

**旁路缓存策略**

写先更新数据库，数据持久化后再删除缓存

**读穿策略**

缓存解决不了问题的时候由缓存区请求数据库，再由缓冲区返给应用

**写穿策略**

更新数据时若缓存区中已有需要更新的数据则更新缓存区后由缓存区更新数据库，否则直接应用更新数据库

**写回策略**（适合写多，但是一致性比较弱）

即时仅更新缓存区，并设置数据脏。数据库这回异步定期从缓存区中更新数据库

### 分布式锁的实现和一致性问题

### 集群和哨兵机制

### 热点key和bigkey的处理
